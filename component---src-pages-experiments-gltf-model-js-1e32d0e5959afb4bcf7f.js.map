{"version":3,"sources":["webpack:///./node_modules/three/examples/jsm/loaders/GLTFLoader.js","webpack:///./src/components/scenes/GltfModelScene.js","webpack:///./src/pages/experiments/gltf-model.js"],"names":["GLTFLoader","manager","call","this","dracoLoader","ddsLoader","GLTFRegistry","objects","get","key","add","object","remove","removeAll","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","resourcePath","scope","path","extractUrlBase","itemStart","_onError","e","console","error","itemError","itemEnd","loader","setPath","setResponseType","crossOrigin","setWithCredentials","data","parse","gltf","setDRACOLoader","setDDSLoader","content","extensions","decodeText","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","json","JSON","undefined","asset","version","Error","extensionsUsed","i","length","extensionName","extensionsRequired","KHR_LIGHTS_PUNCTUAL","GLTFLightsExtension","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","MSFT_TEXTURE_DDS","GLTFTextureDDSExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","indexOf","warn","GLTFParser","name","extension","lightDefs","lights","loadLight","lightIndex","lightNode","lightDef","color","fromArray","range","type","target","position","set","distance","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","Promise","resolve","getMaterialType","extendParams","materialParams","materialDef","parser","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","push","assignTexture","all","BINARY_EXTENSION_HEADER_LENGTH","BINARY_EXTENSION_CHUNK_TYPES","BIN","body","headerView","DataView","header","magic","slice","getUint32","chunkView","chunkIndex","byteLength","chunkLength","chunkType","contentArray","byteOffset","preload","specularGlossinessParams","pbrSpecularGlossiness","shader","uniforms","clone","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","fragmentShader","replace","roughness","metalness","roughnessMap","metalnessMap","specular","value","setHex","glossiness","specularMap","glossinessMap","vertexShader","defines","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossMapDef","createMaterial","params","material","fog","transparent","isGLTFSpecularGlossinessMaterial","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","derivatives","cloneMaterial","source","il","isColor","refreshUniforms","renderer","scene","camera","geometry","uvScaleMap","diffuse","copy","multiplyScalar","isWebGLRenderTarget","texture","matrixAutoUpdate","updateMatrix","uvTransform","matrix","flipEnvMap","isCubeTexture","reflectivity","maxMipLevel","properties","__maxMipLevel","USE_GLOSSINESSMAP","USE_ROUGHNESSMAP","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","decodePrimitive","primitive","bufferViewIndex","bufferView","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","getDependency","then","decodeDracoFile","attribute","extendTexture","transform","offset","rotation","scale","repeat","texCoord","needsUpdate","copySampleValue_","index","result","values","valueSize","beforeStart_","afterEnd_","interpolate_","i1","t0","t","t1","stride","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","WEBGL_CONSTANTS","5120","Int8Array","5121","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","WEBGL_FILTERS","9728","9729","9984","9985","9986","9987","WEBGL_WRAPPINGS","33071","33648","10497","WEBGL_TYPE_SIZES","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","LINEAR","STEP","ALPHA_MODES","MIME_TYPE_FORMATS","resolveURL","test","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","updateMorphTargets","mesh","meshDef","morphTargetInfluences","targetNames","morphTargetDictionary","createAttributesKey","attributesKey","keys","sort","options","cache","primitiveCache","textureLoader","setCrossOrigin","fileLoader","addPrimitiveAttributes","primitiveDef","assignAttributeAccessor","accessorIndex","accessor","setAttribute","gltfAttributeName","indices","setIndex","box","min","max","targets","vector","setX","abs","setY","setZ","expandByVector","boundingBox","sphere","getCenter","center","radius","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","normal","morphPositions","morphNormals","morphAttributes","morphTargetsRelative","addMorphTargets","toTrianglesDrawMode","drawMode","getIndex","getAttribute","count","numberOfTriangles","newIndices","getX","newGeometry","markDefs","getDependencies","dependencies","scenes","animations","cameras","nodeDefs","nodes","skinDefs","skins","meshDefs","meshes","meshReferences","meshUses","skinIndex","skinLength","joints","isBone","nodeIndex","nodeLength","nodeDef","skin","isSkinnedMesh","cacheKey","dependency","loadScene","loadNode","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadTexture","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","uri","reject","bufferViewDef","bufferViews","buffer","sparse","pendingBufferViews","bufferAttribute","itemSize","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","byteStride","ibSlice","floor","ibCacheKey","ib","itemSizeIndices","SCALAR","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setW","textureIndex","URL","window","webkitURL","textureDef","textures","textureExtensions","sourceURI","images","isObjectURL","blob","Blob","mimeType","createObjectURL","getHandler","revokeObjectURL","flipY","format","sampler","samplers","magFilter","minFilter","wrapS","wrapT","mapName","mapDef","isCompressedTexture","assignFinalMaterial","useVertexTangents","tangent","useVertexColors","useFlatShading","useSkinning","useMorphTargets","useMorphNormals","isPoints","uuid","pointsMaterial","sizeAttenuation","isLine","lineMaterial","cachedMaterial","skinning","vertexTangents","vertexColors","flatShading","morphTargets","uv2","uv","onBeforeRender","y","materialIndex","materialType","materials","materialExtensions","sgExtension","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","doubleSided","side","alphaMode","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","encoding","loadGeometries","primitives","createDracoPrimitive","dracoExtension","geometryPromise","mode","cached","promise","meshIndex","depthTest","results","geometries","skinWeight","normalizeSkinWeights","group","cameraIndex","cameraDef","radToDeg","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","id","input","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","TypedKeyframeTrack","targetName","interpolation","traverse","isMesh","outputArray","scaled","j","jl","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","instanceNum","children","o","light","sanitizeNodeName","applyMatrix","quaternion","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","matrixWorld","child","sceneIndex","sceneDef","nodeIds","width","height","fallback","Skull","useLoader","getPrefixedPath","title"],"mappings":"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","file":"component---src-pages-experiments-gltf-model-js-1e32d0e5959afb4bcf7f.js","sourcesContent":["import \"core-js/modules/es6.function.bind\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.typed.float32-array\";\nimport \"core-js/modules/es6.typed.uint32-array\";\nimport \"core-js/modules/es6.typed.uint16-array\";\nimport \"core-js/modules/es6.typed.int16-array\";\nimport \"core-js/modules/es6.typed.int8-array\";\nimport \"core-js/modules/es6.array.map\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.string.repeat\";\nimport \"core-js/modules/es6.typed.data-view\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.is-array\";\nimport \"core-js/modules/es6.promise\";\nimport \"core-js/modules/es6.object.to-string\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.array.index-of\";\nimport \"core-js/modules/es6.typed.uint8-array\";\nimport \"core-js/modules/es6.object.create\";\nimport \"core-js/modules/es6.object.assign\";\n\n/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\nimport { AnimationClip, Bone, Box3, BufferAttribute, BufferGeometry, ClampToEdgeWrapping, Color, DirectionalLight, DoubleSide, FileLoader, FrontSide, Group, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, Line, LineBasicMaterial, LineLoop, LineSegments, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, Loader, LoaderUtils, Material, Math as _Math, Matrix4, Mesh, MeshBasicMaterial, MeshStandardMaterial, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NumberKeyframeTrack, Object3D, OrthographicCamera, PerspectiveCamera, PointLight, Points, PointsMaterial, PropertyBinding, QuaternionKeyframeTrack, RGBAFormat, RGBFormat, RepeatWrapping, Scene, ShaderLib, ShaderMaterial, Skeleton, SkinnedMesh, Sphere, SpotLight, TextureLoader, TriangleFanDrawMode, TriangleStripDrawMode, UniformsUtils, Vector2, Vector3, VectorKeyframeTrack, VertexColors, sRGBEncoding } from \"../../../build/three.module.js\";\n\nvar GLTFLoader = function () {\n  function GLTFLoader(manager) {\n    Loader.call(this, manager);\n    this.dracoLoader = null;\n    this.ddsLoader = null;\n  }\n\n  GLTFLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n    constructor: GLTFLoader,\n    load: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var resourcePath;\n\n      if (this.resourcePath !== '') {\n        resourcePath = this.resourcePath;\n      } else if (this.path !== '') {\n        resourcePath = this.path;\n      } else {\n        resourcePath = LoaderUtils.extractUrlBase(url);\n      } // Tells the LoadingManager to track an extra item, which resolves after\n      // the model is fully loaded. This means the count of items loaded will\n      // be incorrect, but ensures manager.onLoad() does not fire early.\n\n\n      scope.manager.itemStart(url);\n\n      var _onError = function _onError(e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      };\n\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n\n      if (scope.crossOrigin === 'use-credentials') {\n        loader.setWithCredentials(true);\n      }\n\n      loader.load(url, function (data) {\n        try {\n          scope.parse(data, resourcePath, function (gltf) {\n            onLoad(gltf);\n            scope.manager.itemEnd(url);\n          }, _onError);\n        } catch (e) {\n          _onError(e);\n        }\n      }, onProgress, _onError);\n    },\n    setDRACOLoader: function setDRACOLoader(dracoLoader) {\n      this.dracoLoader = dracoLoader;\n      return this;\n    },\n    setDDSLoader: function setDDSLoader(ddsLoader) {\n      this.ddsLoader = ddsLoader;\n      return this;\n    },\n    parse: function parse(data, path, onLoad, onError) {\n      var content;\n      var extensions = {};\n\n      if (typeof data === 'string') {\n        content = data;\n      } else {\n        var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n          try {\n            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n          } catch (error) {\n            if (onError) onError(error);\n            return;\n          }\n\n          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n        } else {\n          content = LoaderUtils.decodeText(new Uint8Array(data));\n        }\n      }\n\n      var json = JSON.parse(content);\n\n      if (json.asset === undefined || json.asset.version[0] < 2) {\n        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));\n        return;\n      }\n\n      if (json.extensionsUsed) {\n        for (var i = 0; i < json.extensionsUsed.length; ++i) {\n          var extensionName = json.extensionsUsed[i];\n          var extensionsRequired = json.extensionsRequired || [];\n\n          switch (extensionName) {\n            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n              extensions[extensionName] = new GLTFLightsExtension(json);\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_UNLIT:\n              extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n              break;\n\n            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n              break;\n\n            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n              break;\n\n            case EXTENSIONS.MSFT_TEXTURE_DDS:\n              extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);\n              break;\n\n            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n              extensions[extensionName] = new GLTFTextureTransformExtension();\n              break;\n\n            case EXTENSIONS.KHR_MESH_QUANTIZATION:\n              extensions[extensionName] = new GLTFMeshQuantizationExtension();\n              break;\n\n            default:\n              if (extensionsRequired.indexOf(extensionName) >= 0) {\n                console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n              }\n\n          }\n        }\n      }\n\n      var parser = new GLTFParser(json, extensions, {\n        path: path || this.resourcePath || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager\n      });\n      parser.parse(onLoad, onError);\n    }\n  });\n  /* GLTFREGISTRY */\n\n  function GLTFRegistry() {\n    var objects = {};\n    return {\n      get: function get(key) {\n        return objects[key];\n      },\n      add: function add(key, object) {\n        objects[key] = object;\n      },\n      remove: function remove(key) {\n        delete objects[key];\n      },\n      removeAll: function removeAll() {\n        objects = {};\n      }\n    };\n  }\n  /*********************************/\n\n  /********** EXTENSIONS ***********/\n\n  /*********************************/\n\n\n  var EXTENSIONS = {\n    KHR_BINARY_GLTF: 'KHR_binary_glTF',\n    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n    KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n  };\n  /**\n   * DDS Texture Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n   *\n   */\n\n  function GLTFTextureDDSExtension(ddsLoader) {\n    if (!ddsLoader) {\n      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader');\n    }\n\n    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n    this.ddsLoader = ddsLoader;\n  }\n  /**\n   * Punctual Lights Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n   */\n\n\n  function GLTFLightsExtension(json) {\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};\n    this.lightDefs = extension.lights || [];\n  }\n\n  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {\n    var lightDef = this.lightDefs[lightIndex];\n    var lightNode;\n    var color = new Color(0xffffff);\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\n    var range = lightDef.range !== undefined ? lightDef.range : 0;\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      case 'point':\n        lightNode = new PointLight(color);\n        lightNode.distance = range;\n        break;\n\n      case 'spot':\n        lightNode = new SpotLight(color);\n        lightNode.distance = range; // Handle spotlight properties.\n\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".');\n    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n\n\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;\n    lightNode.name = lightDef.name || 'light_' + lightIndex;\n    return Promise.resolve(lightNode);\n  };\n  /**\n   * Unlit Materials Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n   */\n\n\n  function GLTFMaterialsUnlitExtension() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n\n  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {\n    return MeshBasicMaterial;\n  };\n\n  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {\n    var pending = [];\n    materialParams.color = new Color(1.0, 1.0, 1.0);\n    materialParams.opacity = 1.0;\n    var metallicRoughness = materialDef.pbrMetallicRoughness;\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /* BINARY EXTENSION */\n\n\n  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n  var BINARY_EXTENSION_HEADER_LENGTH = 12;\n  var BINARY_EXTENSION_CHUNK_TYPES = {\n    JSON: 0x4E4F534A,\n    BIN: 0x004E4942\n  };\n\n  function GLTFBinaryExtension(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');\n    }\n\n    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    var chunkIndex = 0;\n\n    while (chunkIndex < chunkView.byteLength) {\n      var chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      var chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      } // Clients must ignore chunks with unknown types.\n\n\n      chunkIndex += chunkLength;\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.');\n    }\n  }\n  /**\n   * DRACO Mesh Compression Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n   */\n\n\n  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n\n  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n    var json = this.json;\n    var dracoLoader = this.dracoLoader;\n    var bufferViewIndex = primitive.extensions[this.name].bufferView;\n    var gltfAttributeMap = primitive.extensions[this.name].attributes;\n    var threeAttributeMap = {};\n    var attributeNormalizedMap = {};\n    var attributeTypeMap = {};\n\n    for (var attributeName in gltfAttributeMap) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n\n    for (attributeName in primitive.attributes) {\n      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        var accessorDef = json.accessors[primitive.attributes[attributeName]];\n        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function (geometry) {\n          for (var attributeName in geometry.attributes) {\n            var attribute = geometry.attributes[attributeName];\n            var normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== undefined) attribute.normalized = normalized;\n          }\n\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  };\n  /**\n   * Texture Transform Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n   */\n\n\n  function GLTFTextureTransformExtension() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n\n  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {\n    texture = texture.clone();\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset);\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation;\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale);\n    }\n\n    if (transform.texCoord !== undefined) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n\n    texture.needsUpdate = true;\n    return texture;\n  };\n  /**\n   * Specular-Glossiness Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n   */\n\n\n  function GLTFMaterialsPbrSpecularGlossinessExtension() {\n    return {\n      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n      getMaterialType: function getMaterialType() {\n        return ShaderMaterial;\n      },\n      extendParams: function extendParams(materialParams, materialDef, parser) {\n        var pbrSpecularGlossiness = materialDef.extensions[this.name];\n        var shader = ShaderLib['standard'];\n        var uniforms = UniformsUtils.clone(shader.uniforms);\n        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n        var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n        delete uniforms.roughness;\n        delete uniforms.metalness;\n        delete uniforms.roughnessMap;\n        delete uniforms.metalnessMap;\n        uniforms.specular = {\n          value: new Color().setHex(0x111111)\n        };\n        uniforms.glossiness = {\n          value: 0.5\n        };\n        uniforms.specularMap = {\n          value: null\n        };\n        uniforms.glossinessMap = {\n          value: null\n        };\n        materialParams.vertexShader = shader.vertexShader;\n        materialParams.fragmentShader = fragmentShader;\n        materialParams.uniforms = uniforms;\n        materialParams.defines = {\n          'STANDARD': ''\n        };\n        materialParams.color = new Color(1.0, 1.0, 1.0);\n        materialParams.opacity = 1.0;\n        var pending = [];\n\n        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n          var array = pbrSpecularGlossiness.diffuseFactor;\n          materialParams.color.fromArray(array);\n          materialParams.opacity = array[3];\n        }\n\n        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n          pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));\n        }\n\n        materialParams.emissive = new Color(0.0, 0.0, 0.0);\n        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n        materialParams.specular = new Color(1.0, 1.0, 1.0);\n\n        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n        }\n\n        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n          pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));\n          pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));\n        }\n\n        return Promise.all(pending);\n      },\n      createMaterial: function createMaterial(params) {\n        // setup material properties based on MeshStandardMaterial for Specular-Glossiness\n        var material = new ShaderMaterial({\n          defines: params.defines,\n          vertexShader: params.vertexShader,\n          fragmentShader: params.fragmentShader,\n          uniforms: params.uniforms,\n          fog: true,\n          lights: true,\n          opacity: params.opacity,\n          transparent: params.transparent\n        });\n        material.isGLTFSpecularGlossinessMaterial = true;\n        material.color = params.color;\n        material.map = params.map === undefined ? null : params.map;\n        material.lightMap = null;\n        material.lightMapIntensity = 1.0;\n        material.aoMap = params.aoMap === undefined ? null : params.aoMap;\n        material.aoMapIntensity = 1.0;\n        material.emissive = params.emissive;\n        material.emissiveIntensity = 1.0;\n        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n        material.bumpScale = 1;\n        material.normalMap = params.normalMap === undefined ? null : params.normalMap;\n        if (params.normalScale) material.normalScale = params.normalScale;\n        material.displacementMap = null;\n        material.displacementScale = 1;\n        material.displacementBias = 0;\n        material.specularMap = params.specularMap === undefined ? null : params.specularMap;\n        material.specular = params.specular;\n        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n        material.glossiness = params.glossiness;\n        material.alphaMap = null;\n        material.envMap = params.envMap === undefined ? null : params.envMap;\n        material.envMapIntensity = 1.0;\n        material.refractionRatio = 0.98;\n        material.extensions.derivatives = true;\n        return material;\n      },\n\n      /**\n       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n       * copy only properties it knows about or inherits, and misses many properties that would\n       * normally be defined by MeshStandardMaterial.\n       *\n       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n       * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n       * AND also updating `.onBeforeRender` on the parent mesh.\n       *\n       * @param  {ShaderMaterial} source\n       * @return {ShaderMaterial}\n       */\n      cloneMaterial: function cloneMaterial(source) {\n        var target = source.clone();\n        target.isGLTFSpecularGlossinessMaterial = true;\n        var params = this.specularGlossinessParams;\n\n        for (var i = 0, il = params.length; i < il; i++) {\n          var value = source[params[i]];\n          target[params[i]] = value && value.isColor ? value.clone() : value;\n        }\n\n        return target;\n      },\n      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material) {\n        if (material.isGLTFSpecularGlossinessMaterial !== true) {\n          return;\n        }\n\n        var uniforms = material.uniforms;\n        var defines = material.defines;\n        uniforms.opacity.value = material.opacity;\n        uniforms.diffuse.value.copy(material.color);\n        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n        uniforms.map.value = material.map;\n        uniforms.specularMap.value = material.specularMap;\n        uniforms.alphaMap.value = material.alphaMap;\n        uniforms.lightMap.value = material.lightMap;\n        uniforms.lightMapIntensity.value = material.lightMapIntensity;\n        uniforms.aoMap.value = material.aoMap;\n        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities\n        // 1. color map\n        // 2. specular map\n        // 3. normal map\n        // 4. bump map\n        // 5. alpha map\n        // 6. emissive map\n\n        var uvScaleMap;\n\n        if (material.map) {\n          uvScaleMap = material.map;\n        } else if (material.specularMap) {\n          uvScaleMap = material.specularMap;\n        } else if (material.displacementMap) {\n          uvScaleMap = material.displacementMap;\n        } else if (material.normalMap) {\n          uvScaleMap = material.normalMap;\n        } else if (material.bumpMap) {\n          uvScaleMap = material.bumpMap;\n        } else if (material.glossinessMap) {\n          uvScaleMap = material.glossinessMap;\n        } else if (material.alphaMap) {\n          uvScaleMap = material.alphaMap;\n        } else if (material.emissiveMap) {\n          uvScaleMap = material.emissiveMap;\n        }\n\n        if (uvScaleMap !== undefined) {\n          // backwards compatibility\n          if (uvScaleMap.isWebGLRenderTarget) {\n            uvScaleMap = uvScaleMap.texture;\n          }\n\n          if (uvScaleMap.matrixAutoUpdate === true) {\n            uvScaleMap.updateMatrix();\n          }\n\n          uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n        }\n\n        if (material.envMap) {\n          uniforms.envMap.value = material.envMap;\n          uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else:\n          //  WebGLRenderTargetCube will be flipped for backwards compatibility\n          //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\n          // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\n\n          uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;\n          uniforms.reflectivity.value = material.reflectivity;\n          uniforms.refractionRatio.value = material.refractionRatio;\n          uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;\n        }\n\n        uniforms.specular.value.copy(material.specular);\n        uniforms.glossiness.value = material.glossiness;\n        uniforms.glossinessMap.value = material.glossinessMap;\n        uniforms.emissiveMap.value = material.emissiveMap;\n        uniforms.bumpMap.value = material.bumpMap;\n        uniforms.normalMap.value = material.normalMap;\n        uniforms.displacementMap.value = material.displacementMap;\n        uniforms.displacementScale.value = material.displacementScale;\n        uniforms.displacementBias.value = material.displacementBias;\n\n        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv\n\n          defines.USE_ROUGHNESSMAP = '';\n        }\n\n        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n          delete defines.USE_GLOSSINESSMAP;\n          delete defines.USE_ROUGHNESSMAP;\n        }\n      }\n    };\n  }\n  /**\n   * Mesh Quantization Extension\n   *\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n   */\n\n\n  function GLTFMeshQuantizationExtension() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n  /*********************************/\n\n  /********** INTERPOLATION ********/\n\n  /*********************************/\n  // Spline Interpolation\n  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\n\n  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n\n  GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);\n  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n    var result = this.resultBuffer,\n        values = this.sampleValues,\n        valueSize = this.valueSize,\n        offset = index * valueSize * 3 + valueSize;\n\n    for (var i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n\n    return result;\n  };\n\n  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\n\n  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n    var result = this.resultBuffer;\n    var values = this.sampleValues;\n    var stride = this.valueSize;\n    var stride2 = stride * 2;\n    var stride3 = stride * 3;\n    var td = t1 - t0;\n    var p = (t - t0) / td;\n    var pp = p * p;\n    var ppp = pp * p;\n    var offset1 = i1 * stride3;\n    var offset0 = offset1 - stride3;\n    var s2 = -2 * ppp + 3 * pp;\n    var s3 = ppp - pp;\n    var s0 = 1 - s2;\n    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\n    for (var i = 0; i !== stride; i++) {\n      var p0 = values[offset0 + i + stride]; // splineVertex_k\n\n      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\n      var p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\n      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n    }\n\n    return result;\n  };\n  /*********************************/\n\n  /********** INTERNALS ************/\n\n  /*********************************/\n\n  /* CONSTANTS */\n\n\n  var WEBGL_CONSTANTS = {\n    FLOAT: 5126,\n    //FLOAT_MAT2: 35674,\n    FLOAT_MAT3: 35675,\n    FLOAT_MAT4: 35676,\n    FLOAT_VEC2: 35664,\n    FLOAT_VEC3: 35665,\n    FLOAT_VEC4: 35666,\n    LINEAR: 9729,\n    REPEAT: 10497,\n    SAMPLER_2D: 35678,\n    POINTS: 0,\n    LINES: 1,\n    LINE_LOOP: 2,\n    LINE_STRIP: 3,\n    TRIANGLES: 4,\n    TRIANGLE_STRIP: 5,\n    TRIANGLE_FAN: 6,\n    UNSIGNED_BYTE: 5121,\n    UNSIGNED_SHORT: 5123\n  };\n  var WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n  };\n  var WEBGL_FILTERS = {\n    9728: NearestFilter,\n    9729: LinearFilter,\n    9984: NearestMipmapNearestFilter,\n    9985: LinearMipmapNearestFilter,\n    9986: NearestMipmapLinearFilter,\n    9987: LinearMipmapLinearFilter\n  };\n  var WEBGL_WRAPPINGS = {\n    33071: ClampToEdgeWrapping,\n    33648: MirroredRepeatWrapping,\n    10497: RepeatWrapping\n  };\n  var WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n  };\n  var ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex'\n  };\n  var PATH_PROPERTIES = {\n    scale: 'scale',\n    translation: 'position',\n    rotation: 'quaternion',\n    weights: 'morphTargetInfluences'\n  };\n  var INTERPOLATION = {\n    CUBICSPLINE: undefined,\n    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n    // keyframe track will be initialized with a default interpolation type, then modified.\n    LINEAR: InterpolateLinear,\n    STEP: InterpolateDiscrete\n  };\n  var ALPHA_MODES = {\n    OPAQUE: 'OPAQUE',\n    MASK: 'MASK',\n    BLEND: 'BLEND'\n  };\n  var MIME_TYPE_FORMATS = {\n    'image/png': RGBAFormat,\n    'image/jpeg': RGBFormat\n  };\n  /* UTILITY FUNCTIONS */\n\n  function resolveURL(url, path) {\n    // Invalid URL\n    if (typeof url !== 'string' || url === '') return ''; // Host Relative URL\n\n    if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n      path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n    } // Absolute URL http://,https://,//\n\n\n    if (/^(https?:)?\\/\\//i.test(url)) return url; // Data URI\n\n    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL\n\n    if (/^blob:.*$/i.test(url)) return url; // Relative URL\n\n    return path + url;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n   */\n\n\n  function createDefaultMaterial(cache) {\n    if (cache['DefaultMaterial'] === undefined) {\n      cache['DefaultMaterial'] = new MeshStandardMaterial({\n        color: 0xFFFFFF,\n        emissive: 0x000000,\n        metalness: 1,\n        roughness: 1,\n        transparent: false,\n        depthTest: true,\n        side: FrontSide\n      });\n    }\n\n    return cache['DefaultMaterial'];\n  }\n\n  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n    // Add unknown glTF extensions to an object's userData.\n    for (var name in objectDef.extensions) {\n      if (knownExtensions[name] === undefined) {\n        object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n        object.userData.gltfExtensions[name] = objectDef.extensions[name];\n      }\n    }\n  }\n  /**\n   * @param {Object3D|Material|BufferGeometry} object\n   * @param {GLTF.definition} gltfDef\n   */\n\n\n  function assignExtrasToUserData(object, gltfDef) {\n    if (gltfDef.extras !== undefined) {\n      if (typeof gltfDef.extras === 'object') {\n        Object.assign(object.userData, gltfDef.extras);\n      } else {\n        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);\n      }\n    }\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n   *\n   * @param {BufferGeometry} geometry\n   * @param {Array<GLTF.Target>} targets\n   * @param {GLTFParser} parser\n   * @return {Promise<BufferGeometry>}\n   */\n\n\n  function addMorphTargets(geometry, targets, parser) {\n    var hasMorphPosition = false;\n    var hasMorphNormal = false;\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n      if (target.POSITION !== undefined) hasMorphPosition = true;\n      if (target.NORMAL !== undefined) hasMorphNormal = true;\n      if (hasMorphPosition && hasMorphNormal) break;\n    }\n\n    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\n    var pendingPositionAccessors = [];\n    var pendingNormalAccessors = [];\n\n    for (var i = 0, il = targets.length; i < il; i++) {\n      var target = targets[i];\n\n      if (hasMorphPosition) {\n        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;\n        pendingPositionAccessors.push(pendingAccessor);\n      }\n\n      if (hasMorphNormal) {\n        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;\n        pendingNormalAccessors.push(pendingAccessor);\n      }\n    }\n\n    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {\n      var morphPositions = accessors[0];\n      var morphNormals = accessors[1];\n      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n      geometry.morphTargetsRelative = true;\n      return geometry;\n    });\n  }\n  /**\n   * @param {Mesh} mesh\n   * @param {GLTF.Mesh} meshDef\n   */\n\n\n  function updateMorphTargets(mesh, meshDef) {\n    mesh.updateMorphTargets();\n\n    if (meshDef.weights !== undefined) {\n      for (var i = 0, il = meshDef.weights.length; i < il; i++) {\n        mesh.morphTargetInfluences[i] = meshDef.weights[i];\n      }\n    } // .extras has user-defined data, so check that .extras.targetNames is an array.\n\n\n    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n      var targetNames = meshDef.extras.targetNames;\n\n      if (mesh.morphTargetInfluences.length === targetNames.length) {\n        mesh.morphTargetDictionary = {};\n\n        for (var i = 0, il = targetNames.length; i < il; i++) {\n          mesh.morphTargetDictionary[targetNames[i]] = i;\n        }\n      } else {\n        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n      }\n    }\n  }\n\n  function createPrimitiveKey(primitiveDef) {\n    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n    var geometryKey;\n\n    if (dracoExtension) {\n      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);\n    } else {\n      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;\n    }\n\n    return geometryKey;\n  }\n\n  function createAttributesKey(attributes) {\n    var attributesKey = '';\n    var keys = Object.keys(attributes).sort();\n\n    for (var i = 0, il = keys.length; i < il; i++) {\n      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';\n    }\n\n    return attributesKey;\n  }\n  /* GLTF PARSER */\n\n\n  function GLTFParser(json, extensions, options) {\n    this.json = json || {};\n    this.extensions = extensions || {};\n    this.options = options || {}; // loader object cache\n\n    this.cache = new GLTFRegistry(); // BufferGeometry caching\n\n    this.primitiveCache = {};\n    this.textureLoader = new TextureLoader(this.options.manager);\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.fileLoader = new FileLoader(this.options.manager);\n    this.fileLoader.setResponseType('arraybuffer');\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n\n  GLTFParser.prototype.parse = function (onLoad, onError) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions; // Clear the loader cache\n\n    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse\n\n    this.markDefs();\n    Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {\n      var result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser: parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      onLoad(result);\n    })[\"catch\"](onError);\n  };\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n\n\n  GLTFParser.prototype.markDefs = function () {\n    var nodeDefs = this.json.nodes || [];\n    var skinDefs = this.json.skins || [];\n    var meshDefs = this.json.meshes || [];\n    var meshReferences = {};\n    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n\n    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      var joints = skinDefs[skinIndex].joints;\n\n      for (var i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n    // avoid having more than one Mesh with the same name, count\n    // references and rename instances below.\n    //\n    // Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\n\n    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      var nodeDef = nodeDefs[nodeIndex];\n\n      if (nodeDef.mesh !== undefined) {\n        if (meshReferences[nodeDef.mesh] === undefined) {\n          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n        }\n\n        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n    }\n\n    this.json.meshReferences = meshReferences;\n    this.json.meshUses = meshUses;\n  };\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n\n\n  GLTFParser.prototype.getDependency = function (type, index) {\n    var cacheKey = type + ':' + index;\n    var dependency = this.cache.get(cacheKey);\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index);\n          break;\n\n        case 'node':\n          dependency = this.loadNode(index);\n          break;\n\n        case 'mesh':\n          dependency = this.loadMesh(index);\n          break;\n\n        case 'accessor':\n          dependency = this.loadAccessor(index);\n          break;\n\n        case 'bufferView':\n          dependency = this.loadBufferView(index);\n          break;\n\n        case 'buffer':\n          dependency = this.loadBuffer(index);\n          break;\n\n        case 'material':\n          dependency = this.loadMaterial(index);\n          break;\n\n        case 'texture':\n          dependency = this.loadTexture(index);\n          break;\n\n        case 'skin':\n          dependency = this.loadSkin(index);\n          break;\n\n        case 'animation':\n          dependency = this.loadAnimation(index);\n          break;\n\n        case 'camera':\n          dependency = this.loadCamera(index);\n          break;\n\n        case 'light':\n          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);\n          break;\n\n        default:\n          throw new Error('Unknown type: ' + type);\n      }\n\n      this.cache.add(cacheKey, dependency);\n    }\n\n    return dependency;\n  };\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n\n\n  GLTFParser.prototype.getDependencies = function (type) {\n    var dependencies = this.cache.get(type);\n\n    if (!dependencies) {\n      var parser = this;\n      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n      dependencies = Promise.all(defs.map(function (def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n\n    return dependencies;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBuffer = function (bufferIndex) {\n    var bufferDef = this.json.buffers[bufferIndex];\n    var loader = this.fileLoader;\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n    } // If present, GLB container is required to be the first buffer.\n\n\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n\n    var options = this.options;\n    return new Promise(function (resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n\n\n  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n    var bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      var byteLength = bufferViewDef.byteLength || 0;\n      var byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n\n\n  GLTFParser.prototype.loadAccessor = function (accessorIndex) {\n    var parser = this;\n    var json = this.json;\n    var accessorDef = this.json.accessors[accessorIndex];\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      // Ignore empty accessors, which may be used to declare runtime\n      // information about attributes coming from another source (e.g. Draco\n      // compression extension).\n      return Promise.resolve(null);\n    }\n\n    var pendingBufferViews = [];\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      var bufferView = bufferViews[0];\n      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\n      var elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      var itemBytes = elementBytes * itemSize;\n      var byteOffset = accessorDef.byteOffset || 0;\n      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;\n      var normalized = accessorDef.normalized === true;\n      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.\n\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        var ibSlice = Math.floor(byteOffset / byteStride);\n        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\n        var ib = parser.cache.get(ibCacheKey);\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.\n\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\n      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\n\n      if (accessorDef.sparse !== undefined) {\n        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n\n        for (var i = 0, il = sparseIndices.length; i < il; i++) {\n          var index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n        }\n      }\n\n      return bufferAttribute;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n\n\n  GLTFParser.prototype.loadTexture = function (textureIndex) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n    var URL = window.URL || window.webkitURL;\n    var textureDef = json.textures[textureIndex];\n    var textureExtensions = textureDef.extensions || {};\n    var source;\n\n    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n    } else {\n      source = json.images[textureDef.source];\n    }\n\n    var sourceURI = source.uri;\n    var isObjectURL = false;\n\n    if (source.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n        isObjectURL = true;\n        var blob = new Blob([bufferView], {\n          type: source.mimeType\n        });\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    }\n\n    return Promise.resolve(sourceURI).then(function (sourceURI) {\n      // Load Texture resource.\n      var loader = options.manager.getHandler(sourceURI);\n\n      if (!loader) {\n        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n      }\n\n      return new Promise(function (resolve, reject) {\n        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n      });\n    }).then(function (texture) {\n      // Clean up resources and configure Texture.\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n\n      texture.flipY = false;\n      if (textureDef.name !== undefined) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.\n\n      if (source.mimeType in MIME_TYPE_FORMATS) {\n        texture.format = MIME_TYPE_FORMATS[source.mimeType];\n      }\n\n      var samplers = json.samplers || {};\n      var sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\n      return texture;\n    });\n  };\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise}\n   */\n\n\n  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {\n    var parser = this;\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture.isCompressedTexture) {\n        switch (mapName) {\n          case 'aoMap':\n          case 'emissiveMap':\n          case 'metalnessMap':\n          case 'normalMap':\n          case 'roughnessMap':\n            texture.format = RGBFormat;\n            break;\n        }\n      } // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\n\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {\n        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;\n\n        if (transform) {\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n        }\n      }\n\n      materialParams[mapName] = texture;\n    });\n  };\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accomodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n\n\n  GLTFParser.prototype.assignFinalMaterial = function (mesh) {\n    var geometry = mesh.geometry;\n    var material = mesh.material;\n    var extensions = this.extensions;\n    var useVertexTangents = geometry.attributes.tangent !== undefined;\n    var useVertexColors = geometry.attributes.color !== undefined;\n    var useFlatShading = geometry.attributes.normal === undefined;\n    var useSkinning = mesh.isSkinnedMesh === true;\n    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n    if (mesh.isPoints) {\n      var cacheKey = 'PointsMaterial:' + material.uuid;\n      var pointsMaterial = this.cache.get(cacheKey);\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial();\n        Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      var cacheKey = 'LineBasicMaterial:' + material.uuid;\n      var lineMaterial = this.cache.get(cacheKey);\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial();\n        Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n\n      material = lineMaterial;\n    } // Clone the material if it will be modified\n\n\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      var cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';\n      if (useSkinning) cacheKey += 'skinning:';\n      if (useVertexTangents) cacheKey += 'vertex-tangents:';\n      if (useVertexColors) cacheKey += 'vertex-colors:';\n      if (useFlatShading) cacheKey += 'flat-shading:';\n      if (useMorphTargets) cacheKey += 'morph-targets:';\n      if (useMorphNormals) cacheKey += 'morph-normals:';\n      var cachedMaterial = this.cache.get(cacheKey);\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();\n        if (useSkinning) cachedMaterial.skinning = true;\n        if (useVertexTangents) cachedMaterial.vertexTangents = true;\n        if (useVertexColors) cachedMaterial.vertexColors = VertexColors;\n        if (useFlatShading) cachedMaterial.flatShading = true;\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\n        this.cache.add(cacheKey, cachedMaterial);\n      }\n\n      material = cachedMaterial;\n    } // workarounds for mesh and geometry\n\n\n    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n      geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n\n    if (material.isGLTFSpecularGlossinessMaterial) {\n      // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n      mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n    } // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\n\n    if (material.normalScale && !useVertexTangents) {\n      material.normalScale.y = -material.normalScale.y;\n    }\n\n    mesh.material = material;\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n\n\n  GLTFParser.prototype.loadMaterial = function (materialIndex) {\n    var parser = this;\n    var json = this.json;\n    var extensions = this.extensions;\n    var materialDef = json.materials[materialIndex];\n    var materialType;\n    var materialParams = {};\n    var materialExtensions = materialDef.extensions || {};\n    var pending = [];\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n      materialType = MeshStandardMaterial;\n      var metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new Color(1.0, 1.0, 1.0);\n      materialParams.opacity = 1.0;\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        var array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));\n      }\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide;\n    }\n\n    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n    } else {\n      materialParams.transparent = false;\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));\n      materialParams.normalScale = new Vector2(1, 1);\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));\n    }\n\n    return Promise.all(pending).then(function () {\n      var material;\n\n      if (materialType === ShaderMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n\n      if (materialDef.name !== undefined) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\n      if (material.map) material.map.encoding = sRGBEncoding;\n      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;\n      if (material.specularMap) material.specularMap.encoding = sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  };\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   */\n\n\n  function computeBounds(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var box = new Box3();\n\n    if (attributes.POSITION !== undefined) {\n      var accessor = parser.json.accessors[attributes.POSITION];\n      var min = accessor.min;\n      var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n      if (min !== undefined && max !== undefined) {\n        box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));\n      } else {\n        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n        return;\n      }\n    } else {\n      return;\n    }\n\n    var targets = primitiveDef.targets;\n\n    if (targets !== undefined) {\n      var vector = new Vector3();\n\n      for (var i = 0, il = targets.length; i < il; i++) {\n        var target = targets[i];\n\n        if (target.POSITION !== undefined) {\n          var accessor = parser.json.accessors[target.POSITION];\n          var min = accessor.min;\n          var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n          if (min !== undefined && max !== undefined) {\n            // we need to get max of absolute components because target weight is [-1,1]\n            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n            box.expandByVector(vector);\n          } else {\n            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');\n          }\n        }\n      }\n    }\n\n    geometry.boundingBox = box;\n    var sphere = new Sphere();\n    box.getCenter(sphere.center);\n    sphere.radius = box.min.distanceTo(box.max) / 2;\n    geometry.boundingSphere = sphere;\n  }\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {GLTF.Primitive} primitiveDef\n   * @param {GLTFParser} parser\n   * @return {Promise<BufferGeometry>}\n   */\n\n\n  function addPrimitiveAttributes(geometry, primitiveDef, parser) {\n    var attributes = primitiveDef.attributes;\n    var pending = [];\n\n    function assignAttributeAccessor(accessorIndex, attributeName) {\n      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n        geometry.setAttribute(attributeName, accessor);\n      });\n    }\n\n    for (var gltfAttributeName in attributes) {\n      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.\n\n      if (threeAttributeName in geometry.attributes) continue;\n      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n    }\n\n    if (primitiveDef.indices !== undefined && !geometry.index) {\n      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n        geometry.setIndex(accessor);\n      });\n      pending.push(accessor);\n    }\n\n    assignExtrasToUserData(geometry, primitiveDef);\n    computeBounds(geometry, primitiveDef, parser);\n    return Promise.all(pending).then(function () {\n      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n    });\n  }\n  /**\n   * @param {BufferGeometry} geometry\n   * @param {Number} drawMode\n   * @return {BufferGeometry}\n   */\n\n\n  function toTrianglesDrawMode(geometry, drawMode) {\n    var index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      var indices = [];\n      var position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (var i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    var numberOfTriangles = index.count - 2;\n    var newIndices = [];\n\n    if (drawMode === TriangleFanDrawMode) {\n      // gl.TRIANGLE_FAN\n      for (var i = 1; i <= numberOfTriangles; i++) {\n        newIndices.push(index.getX(0));\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n      }\n    } else {\n      // gl.TRIANGLE_STRIP\n      for (var i = 0; i < numberOfTriangles; i++) {\n        if (i % 2 === 0) {\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i + 2));\n        } else {\n          newIndices.push(index.getX(i + 2));\n          newIndices.push(index.getX(i + 1));\n          newIndices.push(index.getX(i));\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    var newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    return newGeometry;\n  }\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n\n\n  GLTFParser.prototype.loadGeometries = function (primitives) {\n    var parser = this;\n    var extensions = this.extensions;\n    var cache = this.primitiveCache;\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var primitive = primitives[i];\n      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry\n\n      var cached = cache[cacheKey];\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise);\n      } else {\n        var geometryPromise;\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);\n        } // Cache this geometry\n\n\n        cache[cacheKey] = {\n          primitive: primitive,\n          promise: geometryPromise\n        };\n        pending.push(geometryPromise);\n      }\n    }\n\n    return Promise.all(pending);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n\n\n  GLTFParser.prototype.loadMesh = function (meshIndex) {\n    var parser = this;\n    var json = this.json;\n    var meshDef = json.meshes[meshIndex];\n    var primitives = meshDef.primitives;\n    var pending = [];\n\n    for (var i = 0, il = primitives.length; i < il; i++) {\n      var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);\n      pending.push(material);\n    }\n\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function (results) {\n      var materials = results.slice(0, results.length - 1);\n      var geometries = results[results.length - 1];\n      var meshes = [];\n\n      for (var i = 0, il = geometries.length; i < il; i++) {\n        var geometry = geometries[i];\n        var primitive = primitives[i]; // 1. create Mesh\n\n        var mesh;\n        var material = materials[i];\n\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n          // .isSkinnedMesh isn't in glTF spec. See .markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);\n\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\n            mesh.normalizeSkinWeights();\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material);\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n\n        mesh.name = meshDef.name || 'mesh_' + meshIndex;\n        if (geometries.length > 1) mesh.name += '_' + i;\n        assignExtrasToUserData(mesh, meshDef);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n\n      var group = new Group();\n\n      for (var i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n\n      return group;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n\n\n  GLTFParser.prototype.loadCamera = function (cameraIndex) {\n    var camera;\n    var cameraDef = this.json.cameras[cameraIndex];\n    var params = cameraDef[cameraDef.type];\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.');\n      return;\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(_Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n    }\n\n    if (cameraDef.name !== undefined) camera.name = cameraDef.name;\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Object>}\n   */\n\n\n  GLTFParser.prototype.loadSkin = function (skinIndex) {\n    var skinDef = this.json.skins[skinIndex];\n    var skinEntry = {\n      joints: skinDef.joints\n    };\n\n    if (skinDef.inverseBindMatrices === undefined) {\n      return Promise.resolve(skinEntry);\n    }\n\n    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n\n\n  GLTFParser.prototype.loadAnimation = function (animationIndex) {\n    var json = this.json;\n    var animationDef = json.animations[animationIndex];\n    var pendingNodes = [];\n    var pendingInputAccessors = [];\n    var pendingOutputAccessors = [];\n    var pendingSamplers = [];\n    var pendingTargets = [];\n\n    for (var i = 0, il = animationDef.channels.length; i < il; i++) {\n      var channel = animationDef.channels[i];\n      var sampler = animationDef.samplers[channel.sampler];\n      var target = channel.target;\n      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\n      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency('node', name));\n      pendingInputAccessors.push(this.getDependency('accessor', input));\n      pendingOutputAccessors.push(this.getDependency('accessor', output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n\n    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {\n      var nodes = dependencies[0];\n      var inputAccessors = dependencies[1];\n      var outputAccessors = dependencies[2];\n      var samplers = dependencies[3];\n      var targets = dependencies[4];\n      var tracks = [];\n\n      for (var i = 0, il = nodes.length; i < il; i++) {\n        var node = nodes[i];\n        var inputAccessor = inputAccessors[i];\n        var outputAccessor = outputAccessors[i];\n        var sampler = samplers[i];\n        var target = targets[i];\n        if (node === undefined) continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        var TypedKeyframeTrack;\n\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = NumberKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\n            break;\n\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack;\n            break;\n        }\n\n        var targetName = node.name ? node.name : node.uuid;\n        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;\n        var targetNames = [];\n\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          // Node may be a Group (glTF mesh with several primitives) or a Mesh.\n          node.traverse(function (object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n\n        var outputArray = outputAccessor.array;\n\n        if (outputAccessor.normalized) {\n          var scale;\n\n          if (outputArray.constructor === Int8Array) {\n            scale = 1 / 127;\n          } else if (outputArray.constructor === Uint8Array) {\n            scale = 1 / 255;\n          } else if (outputArray.constructor == Int16Array) {\n            scale = 1 / 32767;\n          } else if (outputArray.constructor === Uint16Array) {\n            scale = 1 / 65535;\n          } else {\n            throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');\n          }\n\n          var scaled = new Float32Array(outputArray.length);\n\n          for (var j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n\n          outputArray = scaled;\n        }\n\n        for (var j = 0, jl = targetNames.length; j < jl; j++) {\n          var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.\n\n          if (sampler.interpolation === 'CUBICSPLINE') {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n              // must be divided by three to get the interpolant's sampleSize argument.\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n\n\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n\n          tracks.push(track);\n        }\n      }\n\n      var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n      return new AnimationClip(name, undefined, tracks);\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n\n\n  GLTFParser.prototype.loadNode = function (nodeIndex) {\n    var json = this.json;\n    var extensions = this.extensions;\n    var parser = this;\n    var meshReferences = json.meshReferences;\n    var meshUses = json.meshUses;\n    var nodeDef = json.nodes[nodeIndex];\n    return function () {\n      var pending = [];\n\n      if (nodeDef.mesh !== undefined) {\n        pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n          var node;\n\n          if (meshReferences[nodeDef.mesh] > 1) {\n            var instanceNum = meshUses[nodeDef.mesh]++;\n            node = mesh.clone();\n            node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness\n\n            node.onBeforeRender = mesh.onBeforeRender;\n\n            for (var i = 0, il = node.children.length; i < il; i++) {\n              node.children[i].name += '_instance_' + instanceNum;\n              node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;\n            }\n          } else {\n            node = mesh;\n          } // if weights are provided on the node, override weights on the mesh.\n\n\n          if (nodeDef.weights !== undefined) {\n            node.traverse(function (o) {\n              if (!o.isMesh) return;\n\n              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {\n                o.morphTargetInfluences[i] = nodeDef.weights[i];\n              }\n            });\n          }\n\n          return node;\n        }));\n      }\n\n      if (nodeDef.camera !== undefined) {\n        pending.push(parser.getDependency('camera', nodeDef.camera));\n      }\n\n      if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {\n        pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));\n      }\n\n      return Promise.all(pending);\n    }().then(function (objects) {\n      var node; // .isBone isn't in glTF spec. See .markDefs\n\n      if (nodeDef.isBone === true) {\n        node = new Bone();\n      } else if (objects.length > 1) {\n        node = new Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new Object3D();\n      }\n\n      if (node !== objects[0]) {\n        for (var i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n\n      if (nodeDef.name !== undefined) {\n        node.userData.name = nodeDef.name;\n        node.name = PropertyBinding.sanitizeNodeName(nodeDef.name);\n      }\n\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);\n\n      if (nodeDef.matrix !== undefined) {\n        var matrix = new Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix(matrix);\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation);\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n\n      return node;\n    });\n  };\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Scene>}\n   */\n\n\n  GLTFParser.prototype.loadScene = function () {\n    // scene node hierachy builder\n    function buildNodeHierachy(nodeId, parentObject, json, parser) {\n      var nodeDef = json.nodes[nodeId];\n      return parser.getDependency('node', nodeId).then(function (node) {\n        if (nodeDef.skin === undefined) return node; // build skeleton here as well\n\n        var skinEntry;\n        return parser.getDependency('skin', nodeDef.skin).then(function (skin) {\n          skinEntry = skin;\n          var pendingJoints = [];\n\n          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {\n            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));\n          }\n\n          return Promise.all(pendingJoints);\n        }).then(function (jointNodes) {\n          node.traverse(function (mesh) {\n            if (!mesh.isMesh) return;\n            var bones = [];\n            var boneInverses = [];\n\n            for (var j = 0, jl = jointNodes.length; j < jl; j++) {\n              var jointNode = jointNodes[j];\n\n              if (jointNode) {\n                bones.push(jointNode);\n                var mat = new Matrix4();\n\n                if (skinEntry.inverseBindMatrices !== undefined) {\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n                }\n\n                boneInverses.push(mat);\n              } else {\n                console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n              }\n            }\n\n            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\n          });\n          return node;\n        });\n      }).then(function (node) {\n        // build node hierachy\n        parentObject.add(node);\n        var pending = [];\n\n        if (nodeDef.children) {\n          var children = nodeDef.children;\n\n          for (var i = 0, il = children.length; i < il; i++) {\n            var child = children[i];\n            pending.push(buildNodeHierachy(child, node, json, parser));\n          }\n        }\n\n        return Promise.all(pending);\n      });\n    }\n\n    return function loadScene(sceneIndex) {\n      var json = this.json;\n      var extensions = this.extensions;\n      var sceneDef = this.json.scenes[sceneIndex];\n      var parser = this;\n      var scene = new Scene();\n      if (sceneDef.name !== undefined) scene.name = sceneDef.name;\n      assignExtrasToUserData(scene, sceneDef);\n      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n      var nodeIds = sceneDef.nodes || [];\n      var pending = [];\n\n      for (var i = 0, il = nodeIds.length; i < il; i++) {\n        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n      }\n\n      return Promise.all(pending).then(function () {\n        return scene;\n      });\n    };\n  }();\n\n  return GLTFLoader;\n}();\n\nexport { GLTFLoader };","import React, { Suspense } from \"react\"\n\nimport * as THREE from \"three\"\nimport { Canvas, useLoader } from \"react-three-fiber\"\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\"\nimport getPrefixedPath from \"../../getPrefixedPath\"\n\nexport default () => {\n  return (\n    <Canvas>\n      <rectAreaLight\n        intensity={2}\n        width={300}\n        height={300}\n        position={[0, 0, 100]}\n      />\n      <Suspense fallback={null}>\n        <Skull />\n      </Suspense>\n    </Canvas>\n  )\n}\n\nconst Skull = () => {\n  const gltf = useLoader(\n    GLTFLoader,\n    getPrefixedPath(\"/models/skull/scene.gltf\")\n  )\n  return (\n    <group>\n      <primitive object={gltf.scene} />\n    </group>\n  )\n}\n","import React from \"react\"\nimport Experiment from \"../../components/experiment\"\nimport Scene from \"../../components/scenes/GltfModelScene\"\n\nexport default ({ children, width, height }) => {\n  return (\n    <Experiment width={300} height={300} title=\"GLTF Model\">\n      <Scene />\n    </Experiment>\n  )\n}\n"],"sourceRoot":""}